// Generated by CoffeeScript 1.7.1
(function() {
  var Particle, grasky;

  grasky = window.grasky != null ? window.grasky : window.grasky = {};

  grasky.SphereLayout = (function() {
    var BOUNDRY_ATTRACTIVE_CONSTANT, BOUNDRY_DISTANCE, DRAG_CONSTANT, NUM_ITERATIONS, REPULSION_CONSTANT;

    function SphereLayout() {}

    REPULSION_CONSTANT = 0.02;

    DRAG_CONSTANT = 0.05;

    NUM_ITERATIONS = 2000;

    BOUNDRY_DISTANCE = 20;

    BOUNDRY_ATTRACTIVE_CONSTANT = 0.50;

    SphereLayout.prototype.getLayout = function(nodeCount, edges) {
      var i, iteration, other, particle, particles, _i, _j, _k, _l, _len, _len1, _len2, _results;
      particles = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; i = 0 <= nodeCount ? ++_i : --_i) {
          _results.push(new Particle);
        }
        return _results;
      })();
      for (iteration = _i = 0; 0 <= NUM_ITERATIONS ? _i < NUM_ITERATIONS : _i > NUM_ITERATIONS; iteration = 0 <= NUM_ITERATIONS ? ++_i : --_i) {
        for (_j = 0, _len = particles.length; _j < _len; _j++) {
          particle = particles[_j];
          particle.position.add(particle.velocity);
          particle.velocity.add(this._dragForce(particle));
          particle.velocity.add(this._boundryAttractiveForce(particle));
          for (_k = 0, _len1 = particles.length; _k < _len1; _k++) {
            other = particles[_k];
            if (particle !== other) {
              particle.velocity.add(this._repulsiveForce(particle, other));
            }
          }
        }
      }
      _results = [];
      for (_l = 0, _len2 = particles.length; _l < _len2; _l++) {
        particle = particles[_l];
        _results.push(particle.position);
      }
      return _results;
    };

    SphereLayout.prototype._dragForce = function(particle) {
      return particle.velocity.clone().multiplyScalar(-DRAG_CONSTANT);
    };

    SphereLayout.prototype._repulsiveForce = function(particle, other) {
      var direction, distance;
      distance = particle.position.distanceTo(other.position);
      direction = new THREE.Vector3().subVectors(particle.position, other.position);
      return direction.setLength(REPULSION_CONSTANT / distance);
    };

    SphereLayout.prototype._boundryAttractiveForce = function(particle) {
      var distance;
      distance = Math.max(BOUNDRY_DISTANCE - particle.position.length());
      return particle.position.clone().setLength(BOUNDRY_ATTRACTIVE_CONSTANT * distance);
    };

    return SphereLayout;

  })();

  Particle = (function() {
    function Particle() {
      this.position = new THREE.Vector3(Math.random(), Math.random(), Math.random());
      this.velocity = new THREE.Vector3;
    }

    return Particle;

  })();

}).call(this);
