// Generated by CoffeeScript 1.7.1
(function() {
  var grasky;

  grasky = window.grasky != null ? window.grasky : window.grasky = {};

  grasky.Edge = (function() {
    var COLOR, RADIUS, TEXT_COLOR, alignCylinderBetweenPoints, createCylinder, createText, getWidth;

    RADIUS = 0.0625;

    COLOR = 0xc0c0c0;

    TEXT_COLOR = 0x505050;

    function Edge(node1, node2, text, scene, id) {
      this.text = text;
      this._scene = scene;
      this.nodes = [node1, node2];
      this.mesh = createCylinder();
      scene.add(this.mesh);
      this._initializeLabel();
    }

    Edge.prototype._initializeLabel = function() {
      this.label = createText(this.text);
      this.label.width = getWidth(this.label);
      return this._scene.add(this.label);
    };

    createCylinder = function() {
      var geometry, material;
      geometry = new THREE.CylinderGeometry(RADIUS, RADIUS, 1);
      material = new THREE.MeshLambertMaterial({
        color: COLOR
      });
      return new THREE.Mesh(geometry, material);
    };

    createText = function(text) {
      var geometry, material;
      geometry = new THREE.TextGeometry(text, {
        size: 0.3,
        height: 0.03
      });
      material = new THREE.MeshBasicMaterial({
        color: TEXT_COLOR
      });
      return new THREE.Mesh(geometry, material);
    };

    getWidth = function(mesh) {
      var boundingBox;
      mesh.geometry.computeBoundingBox();
      boundingBox = mesh.geometry.boundingBox;
      return boundingBox.max.x - boundingBox.min.x;
    };

    Edge.prototype.setText = function(text) {
      if (text !== this.text) {
        this.text = text;
        this._scene.remove(this.label);
        return this._initializeLabel();
      }
    };

    Edge.prototype.updatePosition = function(camera) {
      var end, midpoint, start;
      start = this.nodes[0].mesh.position;
      end = this.nodes[1].mesh.position;
      alignCylinderBetweenPoints(this.mesh, start, end);
      midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
      this.label.rotation.set(0, camera.rotation.y, 0, 'YXZ');
      this.label.position.copy(midpoint);
      this.label.translateX(-this.label.width / 2);
      return this.label.translateZ(0.6);
    };

    alignCylinderBetweenPoints = function(cylinder, point1, point2) {
      var arrow, direction;
      if (point1.equals(point2)) {
        return cylinder.scale.y = 0.01;
      } else {
        direction = new THREE.Vector3().subVectors(point2, point1);
        arrow = new THREE.ArrowHelper(direction.clone().normalize(), point1, 1);
        cylinder.scale.y = direction.length();
        cylinder.rotation.copy(arrow.rotation);
        return cylinder.position.addVectors(point1, direction.multiplyScalar(0.5));
      }
    };

    Edge.prototype.getOtherNode = function(node) {
      if (node === this.nodes[0]) {
        return this.nodes[1];
      } else if (node === this.nodes[1]) {
        return this.nodes[0];
      } else {
        return console.error('Unexpected node in edge');
      }
    };

    Edge.prototype.dispose = function() {
      this.mesh.geometry.dispose;
      this.mesh.material.dispose;
      this.mesh.dispose;
      this.mesh = null;
      this.label.geometry.dispose;
      this.label.material.dispose;
      this.label.dispose;
      return this.label = null;
    };

    return Edge;

  })();

}).call(this);
