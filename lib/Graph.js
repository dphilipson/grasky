// Generated by CoffeeScript 1.7.1
(function() {
  var grasky,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  grasky = window.grasky != null ? window.grasky : window.grasky = {};

  grasky.Graph = (function() {
    var CAMERA_DISTANCE, CLICK_TIMEOUT_MILLIS, DraggedNode, FLY_SPEED, LOOP_PERIOD_MILLIS, NODE_FLIGHT_TIME_MILLIS, SKYBOX_DISTANCE, TWO_PI, averageVectors;

    TWO_PI = 2 * Math.PI;

    CAMERA_DISTANCE = 40;

    SKYBOX_DISTANCE = 5000;

    LOOP_PERIOD_MILLIS = 15;

    NODE_FLIGHT_TIME_MILLIS = 1000;

    CLICK_TIMEOUT_MILLIS = 250;

    FLY_SPEED = 0.25;

    function Graph(canvas) {
      var renderLoop, updateLoop;
      this._canvas = canvas;
      this._nodes = new grasky.LinkedDict;
      this._edges = [];
      this._selectionListeners = [];
      this._draggedNodes = {};
      this._draggedNodeDistance = 0;
      this._mouseX = 0;
      this._mouseY = 0;
      this._keysHeld = {};
      this._needsOrientationUpdate = false;
      this._scene = new THREE.Scene;
      this._camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1.1, 10000);
      this._renderer = new THREE.WebGLRenderer({
        canvas: canvas
      });
      this._renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      this._camera.position.z = CAMERA_DISTANCE;
      this._initializeLights();
      this._initializeSkybox();
      this._initializeMouseListeners();
      this._initializeKeyboardListeners();
      renderLoop = (function(_this) {
        return function() {
          var edge, _i, _len, _ref;
          _this._fixLabelRotations();
          _this._updateDraggedNodePositions();
          _ref = _this._edges;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            edge = _ref[_i];
            edge.updatePosition(_this._camera);
          }
          _this._renderer.render(_this._scene, _this._camera);
          return requestAnimationFrame(renderLoop);
        };
      })(this);
      renderLoop();
      updateLoop = (function(_this) {
        return function() {
          var node, _i, _len, _ref;
          _ref = _this._nodes.values();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            node.updateFlight(LOOP_PERIOD_MILLIS / NODE_FLIGHT_TIME_MILLIS);
          }
          _this._updateCameraMovement();
          return setTimeout(updateLoop, LOOP_PERIOD_MILLIS);
        };
      })(this);
      updateLoop();
    }

    Graph.prototype._initializeLights = function() {
      var ambientLight, directionalLight;
      directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0.5, 1, 2);
      this._scene.add(directionalLight);
      ambientLight = new THREE.AmbientLight(0x404040);
      return this._scene.add(ambientLight);
    };

    Graph.prototype._initializeSkybox = function() {
      var filename, filenames, material, path, shader, sideLength, skybox, textureCube, urls;
      path = 'statics/textures/skybox/';
      filenames = ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'];
      urls = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = filenames.length; _i < _len; _i++) {
          filename = filenames[_i];
          _results.push(path + filename);
        }
        return _results;
      })();
      textureCube = THREE.ImageUtils.loadTextureCube(urls);
      shader = THREE.ShaderLib['cube'];
      shader.uniforms['tCube'].value = textureCube;
      material = new THREE.ShaderMaterial({
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: shader.uniforms,
        side: THREE.BackSide
      });
      sideLength = 2 * SKYBOX_DISTANCE;
      skybox = new THREE.Mesh(new THREE.BoxGeometry(sideLength, sideLength, sideLength), material);
      return this._scene.add(skybox);
    };

    Graph.prototype.addNode = function(id, text) {
      if (!this._nodes.containsKey(id)) {
        return this._nodes.put(id, new grasky.Node(id, text, this._scene));
      } else {
        return console.error("Tried to add an existing node with id " + id);
      }
    };

    Graph.prototype.removeNode = function(id) {
      var edge, node, _i, _len, _ref;
      node = this._nodes.get(id);
      if (node) {
        this._scene.remove(node.mesh);
        node.dispose;
        this._nodes.remove(id);
        _ref = _.filter(this._edges, (function(e) {
          return __indexOf.call(e.nodes, node) >= 0;
        }));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          this._removeEdge(edge);
        }
        if (node.isSelected) {
          return this._notifySelectionListeners;
        }
      } else {
        return console.warn("Tried to remove nonexistant node with id " + id);
      }
    };

    Graph.prototype.addEdge = function(id1, id2, text, id) {
      var node1, node2;
      if (!this.getEdge(id1, id2)) {
        node1 = this._nodes.get(id1);
        node2 = this._nodes.get(id2);
        return this._edges.push(new grasky.Edge(node1, node2, text, this._scene, id));
      } else {
        return console.error("Tried to add an existing edge with ids " + id1 + ", " + id2);
      }
    };

    Graph.prototype.removeEdge = function(id1, id2) {
      var edge;
      edge = this.getEdge(id1, id2);
      if (edge) {
        return this._removeEdge(edge);
      } else {
        return console.warn("Tried to remove nonexistant edge with ids " + id1 + ", " + id2);
      }
    };

    Graph.prototype._removeEdge = function(edge) {
      var e;
      this._scene.remove(edge.mesh);
      this._scene.remove(edge.label);
      edge.dispose;
      return this._edges = (function() {
        var _i, _len, _ref, _results;
        _ref = this._edges;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          if (e !== edge) {
            _results.push(e);
          }
        }
        return _results;
      }).call(this);
    };

    Graph.prototype.getEdge = function(id1, id2) {
      return _.find(this._edges, function(edge) {
        var ids, n;
        ids = (function() {
          var _i, _len, _ref, _results;
          _ref = edge.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(n.id);
          }
          return _results;
        })();
        return (_.contains(ids, id1)) && (_.contains(ids, id2));
      });
    };

    Graph.prototype.addSelectionListener = function(callback) {
      return this._selectionListeners.push(callback);
    };

    Graph.prototype.removeSelectionListener = function(callback) {
      return this._selectionListeners = _.reject(this._selectionListeners, function(c) {
        return c === callback;
      });
    };

    Graph.prototype.setSelection = function(id, selected) {
      var node;
      node = this._nodes.get(id);
      if (node) {
        return this._setSelectionInternal(node, selected);
      } else {
        return console.warn("Tried to set selection of nonexistant node with id " + id);
      }
    };

    Graph.prototype._setAsOnlySelectedNode = function(node) {
      this._nodes.foreach(function(n) {
        return n.setSelected(false);
      });
      node.setSelected(true);
      return this._notifySelectionListeners();
    };

    Graph.prototype._clearSelection = function() {
      this._nodes.foreach(function(n) {
        return n.setSelected(false);
      });
      return this._notifySelectionListeners();
    };

    Graph.prototype._toggleSelection = function(node) {
      return this._setSelectionInternal(node, !node.selected);
    };

    Graph.prototype._setSelectionInternal = function(node, selected) {
      node.setSelected(selected);
      return this._notifySelectionListeners();
    };

    Graph.prototype._notifySelectionListeners = function() {
      var listener, n, selectedIds, _i, _len, _ref;
      selectedIds = (function() {
        var _i, _len, _ref, _results;
        _ref = this._getSelectedNodes();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(n.id);
        }
        return _results;
      }).call(this);
      _ref = this._selectionListeners.slice();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        listener(selectedIds);
      }
    };

    Graph.prototype._getSelectedNodes = function() {
      var n, _i, _len, _ref, _results;
      _ref = this._nodes.values();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (n.selected) {
          _results.push(n);
        }
      }
      return _results;
    };

    Graph.prototype.applyLayout = function(layout) {
      var center, edge, edgesByIndex, i, indices, locations, n, node, nodeIds, nodes, selectedNodes, target, _i, _j, _k, _len, _ref, _ref1, _ref2;
      selectedNodes = this._getSelectedNodes();
      nodes = selectedNodes.length > 0 ? selectedNodes : this._nodes.values();
      if (nodes.length === 0) {
        return;
      }
      center = selectedNodes.length === 0 ? new THREE.Vector3 : averageVectors((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          _results.push(node.mesh.position);
        }
        return _results;
      })());
      nodeIds = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          n = nodes[_i];
          _results.push(n.id);
        }
        return _results;
      })();
      indices = {};
      for (i = _i = 0, _ref = nodeIds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        indices[nodeIds[i]] = i;
      }
      edgesByIndex = [];
      _ref1 = this._edges;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        edge = _ref1[_j];
        if (edge.nodes[0].id in indices && edge.nodes[1].id in indices) {
          edgesByIndex.push([indices[edge.nodes[0].id], indices[edge.nodes[1].id]]);
        }
      }
      locations = layout.getLayout(nodeIds.length, edgesByIndex);
      for (i = _k = 0, _ref2 = nodeIds.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        target = locations[i].add(center);
        nodes[i].setFlightTarget(target.x, target.y, target.z);
      }
    };

    averageVectors = function(vectors) {
      var sum, vector, _i, _len;
      sum = new THREE.Vector3;
      for (_i = 0, _len = vectors.length; _i < _len; _i++) {
        vector = vectors[_i];
        sum.add(vector);
      }
      return sum.multiplyScalar(1 / vectors.length);
    };

    Graph.prototype._initializeMouseListeners = function() {
      var clickedNode, mouseLookActive, mousedownTimer, reset, wasSelectedAlready;
      mouseLookActive = false;
      mousedownTimer = null;
      clickedNode = null;
      wasSelectedAlready = false;
      $(this._canvas).mousedown((function(_this) {
        return function(event) {
          var distance, nodeCanvasPosition, offset, selectedNode;
          mousedownTimer = new THREE.Clock();
          mousedownTimer.start();
          clickedNode = _this._getNodeAtCanvasPoint(event.offsetX, event.offsetY);
          if (clickedNode) {
            wasSelectedAlready = clickedNode.selected;
            if (!wasSelectedAlready) {
              if (event.ctrlKey || event.shiftKey) {
                _this._setSelectionInternal(clickedNode, true);
              } else {
                _this._setAsOnlySelectedNode(clickedNode);
              }
            }
            return _this._draggedNodes = (function() {
              var _i, _len, _ref, _results;
              _ref = this._getSelectedNodes();
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                selectedNode = _ref[_i];
                nodeCanvasPosition = this._getCanvasPointFromPosition(selectedNode.mesh.position);
                offset = new THREE.Vector2().subVectors(nodeCanvasPosition, new THREE.Vector2(event.offsetX, event.offsetY));
                distance = this._camera.position.distanceTo(selectedNode.mesh.position);
                _results.push(new DraggedNode(selectedNode, offset, distance));
              }
              return _results;
            }).call(_this);
          } else {
            mouseLookActive = true;
            _this._mouseX = event.offsetX;
            return _this._mouseY = event.offsetY;
          }
        };
      })(this));
      reset = (function(_this) {
        return function() {
          _this._draggedNodes = [];
          mouseLookActive = false;
          clickedNode = null;
          return mousedownTimer = null;
        };
      })(this);
      $(this._canvas).mouseup((function(_this) {
        return function(event) {
          var modifierHeld, wasClick;
          if (mousedownTimer) {
            wasClick = 1000 * mousedownTimer.getElapsedTime() < CLICK_TIMEOUT_MILLIS;
            modifierHeld = event.ctrlKey || event.shiftKey;
            if (wasClick) {
              if (clickedNode) {
                if (modifierHeld) {
                  if (wasSelectedAlready) {
                    _this._setSelectionInternal(clickedNode, false);
                  }
                } else {
                  _this._setAsOnlySelectedNode(clickedNode);
                }
              } else if (!modifierHeld) {
                _this._clearSelection();
              }
            }
          }
          return reset();
        };
      })(this));
      $(this._canvas).mouseout((function(_this) {
        return function() {
          return reset();
        };
      })(this));
      return $(this._canvas).mousemove((function(_this) {
        return function(event) {
          var x, xDelta, y, yDelta;
          x = event.offsetX;
          y = event.offsetY;
          xDelta = x - _this._mouseX;
          yDelta = y - _this._mouseY;
          _this._mouseX = x;
          _this._mouseY = y;
          if (mouseLookActive) {
            return _this._updateRotation(xDelta, yDelta);
          }
        };
      })(this));
    };

    Graph.prototype._getNodeAtCanvasPoint = function(x, y) {
      var intersects, n, raycaster, vector;
      vector = this._getVectorFromCanvasPoint(x, y);
      raycaster = new THREE.Raycaster(this._camera.position, vector);
      intersects = raycaster.intersectObjects((function() {
        var _i, _len, _ref, _results;
        _ref = this._nodes.values();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(n.mesh);
        }
        return _results;
      }).call(this));
      if (intersects.length > 0) {
        return intersects[0].object.node;
      }
    };

    Graph.prototype._getVectorFromCanvasPoint = function(x, y) {
      var vector;
      this._camera.updateMatrixWorld();
      vector = new THREE.Vector3(2 * x / this._canvas.clientWidth - 1, -2 * y / this._canvas.clientHeight + 1, 0.5);
      return new THREE.Projector().unprojectVector(vector, this._camera).sub(this._camera.position).normalize();
    };

    Graph.prototype._getCanvasPointFromPosition = function(position) {
      var vector, x, y;
      vector = new THREE.Vector3().copy(position);
      new THREE.Projector().projectVector(vector, this._camera);
      x = (vector.x + 1) / 2 * this._canvas.clientWidth;
      y = (1 - vector.y) / 2 * this._canvas.clientHeight;
      return new THREE.Vector2(x, y);
    };

    Graph.prototype._updateRotation = function(deltaX, deltaY) {
      var newPitch, newYaw, pitch, yaw;
      yaw = this._camera.rotation.y;
      pitch = this._camera.rotation.x;
      newYaw = yaw - deltaX * TWO_PI / 1500;
      newPitch = pitch - deltaY * TWO_PI / 1500;
      newPitch = Math.min(Math.PI / 2, Math.max(-Math.PI / 2, newPitch));
      this._camera.rotation.set(newPitch, newYaw, this._camera.rotation.z, 'YXZ');
      return this._needsOrientationUpdate = true;
    };

    Graph.prototype._fixLabelRotations = function() {
      if (this._needsOrientationUpdate) {
        this._nodes.foreach((function(_this) {
          return function(node) {
            var label;
            label = node.label;
            label.translateX(label.width / 2);
            label.rotation.set(0, _this._camera.rotation.y, 0, 'YXZ');
            return label.translateX(-label.width / 2);
          };
        })(this));
        return this._needsOrientationUpdate = false;
      }
    };

    Graph.prototype._updateDraggedNodePositions = function() {
      var draggedNode, vector, _i, _len, _ref, _results;
      _ref = this._draggedNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        draggedNode = _ref[_i];
        vector = this._getVectorFromCanvasPoint(this._mouseX + draggedNode.offset.x, this._mouseY + draggedNode.offset.y);
        vector.setLength(draggedNode.distance).add(this._camera.position);
        _results.push(draggedNode.node.setPosition(vector.x, vector.y, vector.z));
      }
      return _results;
    };

    Graph.prototype._initializeKeyboardListeners = function() {
      $(document).keydown((function(_this) {
        return function(event) {
          var node, _i, _len, _ref;
          _this._keysHeld[event.which] = true;
          if (event.which === 8 || event.which === 46) {
            _ref = _this._getSelectedNodes();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _this.removeNode(node.id);
            }
            return event.preventDefault();
          }
        };
      })(this));
      return $(document).keyup((function(_this) {
        return function(event) {
          return delete _this._keysHeld[event.which];
        };
      })(this));
    };

    Graph.prototype._updateCameraMovement = function() {
      var aPressed, dPressed, forward, right, sPressed, wPressed;
      wPressed = 'W'.charCodeAt() in this._keysHeld;
      aPressed = 'A'.charCodeAt() in this._keysHeld;
      sPressed = 'S'.charCodeAt() in this._keysHeld;
      dPressed = 'D'.charCodeAt() in this._keysHeld;
      forward = (wPressed ? 1 : 0) - (sPressed ? 1 : 0);
      right = (dPressed ? 1 : 0) - (aPressed ? 1 : 0);
      this._camera.translateZ(-FLY_SPEED * forward);
      return this._camera.translateX(FLY_SPEED * right);
    };

    Graph.prototype.fixViewBounds = function() {
      var height, width;
      width = this._canvas.clientWidth;
      height = this._canvas.clientHeight;
      this._camera.aspect = width / height;
      this._camera.updateProjectionMatrix();
      return this._renderer.setSize(width, height);
    };

    DraggedNode = (function() {
      function DraggedNode(node, offset, distance) {
        this.node = node;
        this.offset = offset;
        this.distance = distance;
      }

      return DraggedNode;

    })();

    return Graph;

  })();

}).call(this);
